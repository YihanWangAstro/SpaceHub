<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.16">
  <compounddef id="namespace_space_h_1_1_lazy" kind="namespace" language="C++">
    <compoundname>SpaceH::Lazy</compoundname>
    <innerclass refid="struct_space_h_1_1_lazy_1_1_binary___expr" prot="public">SpaceH::Lazy::Binary_Expr</innerclass>
    <innerclass refid="struct_space_h_1_1_lazy_1_1_expr" prot="public">SpaceH::Lazy::Expr</innerclass>
    <innerclass refid="struct_space_h_1_1_lazy_1_1_larray" prot="public">SpaceH::Lazy::Larray</innerclass>
    <innerclass refid="struct_space_h_1_1_lazy_1_1_larray_3_01_t_00_01_len_00_01true_01_4" prot="public">SpaceH::Lazy::Larray&lt; T, Len, true &gt;</innerclass>
    <innerclass refid="struct_space_h_1_1_lazy_1_1_slice" prot="public">SpaceH::Lazy::Slice</innerclass>
    <innerclass refid="struct_space_h_1_1_lazy_1_1_slice___expr" prot="public">SpaceH::Lazy::Slice_Expr</innerclass>
    <innerclass refid="struct_space_h_1_1_lazy_1_1_unary___expr" prot="public">SpaceH::Lazy::Unary_Expr</innerclass>
      <sectiondef kind="var">
          <memberdef kind="variable" id="lazy__expr_8h_1a279d033332d618b8fe5935fc0bd2615d" prot="public" static="no"
                     mutable="no">
              <type>auto</type>
              <definition>auto SpaceH::Lazy::OP__LINE__</definition>
              <argsstring></argsstring>
              <name>OP__LINE__</name>
              <initializer>=[](const auto &amp;lhs, const auto &amp;rhs)-&gt; decltype( lhs + rhs ) {return ( lhs + rhs
                  );}
              </initializer>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="91" column="11" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="91" bodyend="-1"/>
          </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="lazy__array_8h_1a2e9fc8a531a641d52ae48dd739b15076" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool SpaceH::Lazy::leq_cache_line</definition>
        <argsstring>(size_t len=1)</argsstring>
        <name>leq_cache_line</name>
        <param>
          <type>size_t</type>
          <declname>len</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lazy-evaluation/lazy_array.h" line="15" column="24" bodyfile="lazy-evaluation/lazy_array.h" bodystart="15" bodyend="17"/>
      </memberdef>
      <memberdef kind="function" id="lazy__expr_8h_1aeb257316187aeda2523266d9879718b4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>IsExpr</declname>
            <defname>IsExpr</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>const auto</type>
        <definition>const auto SpaceH::Lazy::eval_at</definition>
        <argsstring>(std::enable_if_t&lt; IsExpr, T &gt; const &amp;expr, Args &amp;&amp;...args)</argsstring>
        <name>eval_at</name>
        <param>
          <type>std::enable_if_t&lt; IsExpr, T &gt; const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lazy-evaluation/lazy_expr.h" line="20" column="23" bodyfile="lazy-evaluation/lazy_expr.h" bodystart="20" bodyend="22"/>
      </memberdef>
      <memberdef kind="function" id="lazy__expr_8h_1a8b63f7f18bba2a2104de6ec4a38d752b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>IsExpr</declname>
            <defname>IsExpr</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>const auto</type>
        <definition>const auto SpaceH::Lazy::eval_at</definition>
        <argsstring>(std::enable_if_t&lt;!IsExpr, T &gt; const &amp;expr, Args &amp;&amp;...args)</argsstring>
        <name>eval_at</name>
        <param>
          <type>std::enable_if_t&lt;!IsExpr, T &gt; const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lazy-evaluation/lazy_expr.h" line="25" column="23" bodyfile="lazy-evaluation/lazy_expr.h" bodystart="25" bodyend="27"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a7eca1aaecebef4e4b13c4e5d8ea6a3b5" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator+
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator+</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="91" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="91" bodyend="91"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a229ad375ecfa1eb16df325960ed8838b" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator+
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator+</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="91" column="262" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="91" bodyend="91"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a85dad28c588527f3385cb68a2d554433" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator+
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator+</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="91" column="419" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="91" bodyend="91"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a3a8d4d6f8a5c2b20775f484c88490c80" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator-
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator-</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="92" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="92" bodyend="92"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a225606e16b3e38da3878149cad2c62d6" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator-
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator-</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="92" column="262" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="92" bodyend="92"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a48b2b3840e8ab95e0d5b47096b2cfd10" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator-
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator-</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="92" column="419" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="92" bodyend="92"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a715d571c28ef6b2c588b6b334051d96d" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator*
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator*</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="93" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="93" bodyend="93"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a506da0d467cf1c9111d61e5eda6f9890" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator*
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator*</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="93" column="262" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="93" bodyend="93"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1acdccb6e8e32db9902aad46b76586c13e" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator*
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator*</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="93" column="419" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="93" bodyend="93"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1aee0cfb13cc5ee0a267e2a65603e02ff0" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator/
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator/</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="94" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="94" bodyend="94"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a7fffe107bb23ef589cb12c2635cc1532" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator/
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator/</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="94" column="262" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="94" bodyend="94"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1aab9fe8c5ae348556ae2be43ca4a7d069" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator/
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator/</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="94" column="419" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="94" bodyend="94"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a66085f75cca9acc0e9aa13849e68d23b" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator%
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator%</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="95" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="95" bodyend="95"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1aee6b3f24996f9b4584442b6f2bf93f86" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator%
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator%</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="95" column="262" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="95" bodyend="95"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a402a52d9f15792a08e28c1918a209c58" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator%
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator%</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="95" column="419" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="95" bodyend="95"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1aa9d2e45f4ab1a65e6f4eee6dfbdfcde4" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator==
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator==</name>
        <param>
            <type>const Lhs &amp;</type>
            <declname>lhs</declname>
        </param>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt; &amp;
            </type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="96" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="96" bodyend="96"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1af1489bb4487a34a4a2f51536b32b08b9" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator==
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator==</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="96" column="263" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="96" bodyend="96"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a4f46f60044d1cdd6632c85d8dfc97769" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator==
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator==</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="96" column="421" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="96" bodyend="96"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1aabb16a9e93a31b107a45d42e8a1da676" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator!=
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator!=</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="97" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="97" bodyend="97"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1af947ac6977c556b4352c7a7f7459faca" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator!=
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator!=</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt; &amp;
            </type>
            <declname>lhs</declname>
        </param>
        <param>
            <type>const Rhs &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="97" column="263" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="97" bodyend="97"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1acec8c8438ebed2a695c95aef15fb50b7" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator!=
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator!=</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="97" column="421" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="97" bodyend="97"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a38a42c862506241e4f8973e26d1691f7" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator&lt;
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator&lt;</name>
        <param>
            <type>const Lhs &amp;</type>
            <declname>lhs</declname>
        </param>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt; &amp;
            </type>
            <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="98" column="11" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="98" bodyend="98"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a2ab2076029c37c6618251768cd5841f5" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator&lt;
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator&lt;</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
              </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="98" column="11" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="98" bodyend="98"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a7d601229647d2ed95c2bfbd84483d8c4" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator&lt;
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator&lt;</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt; &amp;
            </type>
            <declname>lhs</declname>
        </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="98" column="11" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="98" bodyend="98"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a855e2df47d842963ba769cb4f3c9f191" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator&gt;
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator&gt;</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="99" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="99" bodyend="99"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a31586fd154fbc622269ec5513eed5ce9" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator&gt;
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator&gt;</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="99" column="262" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="99" bodyend="99"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1ac3402ac154983ca216293aac0f3372d5" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator&gt;
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator&gt;</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt; &amp;
            </type>
            <declname>lhs</declname>
        </param>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt; &amp;
            </type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="99" column="419" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="99" bodyend="99"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a82cf2db802999b22a7fad1a22daa7124" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator&lt;=
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator&lt;=</name>
        <param>
            <type>const Lhs &amp;</type>
            <declname>lhs</declname>
        </param>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt; &amp;
            </type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="100" column="11" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="100" bodyend="100"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a35cb4846b5eb1c0b7d44c9a7bfdc028d" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator&lt;=
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator&lt;=</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="100" column="11" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="100" bodyend="100"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1ac0c05592eb27752053e882a1dbb18f5e" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator&lt;=
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator&lt;=</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt; &amp;
            </type>
            <declname>lhs</declname>
        </param>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt; &amp;
            </type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="100" column="11" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="100" bodyend="100"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1acf2422f09fcf41cbcc145367a5340cb9" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator&gt;=
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator&gt;=</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="101" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="101" bodyend="101"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a16dd56acd7953e2f164ecf1c92fac3b3" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator&gt;=
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator&gt;=</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="101" column="263"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="101" bodyend="101"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a64f88a51b9c1c98ed816cee6a89837b9" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator&gt;=
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator&gt;=</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="101" column="421"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="101" bodyend="101"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1ab693d6900c8625dbe0326a8188310601" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator&amp;&amp;
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator&amp;&amp;</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="102" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="102" bodyend="102"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a449c938f3d50f06499be8b6440dff5c5" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator&amp;&amp;
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator&amp;&amp;</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt; &amp;
            </type>
            <declname>lhs</declname>
        </param>
        <param>
            <type>const Rhs &amp;</type>
            <declname>rhs</declname>
        </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="102" column="263"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="102" bodyend="102"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a672f9d1ac5c241c0eb42ba07aec061ad" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt;
                  SpaceH::Lazy::operator&amp;&amp;
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator&amp;&amp;</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="102" column="421"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="102" bodyend="102"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a8058d96ec41b3127aee4f0fed84b444d" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator||
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator||</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="103" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="103" bodyend="103"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1af65f7c046155d0ae3bed24913fbaca57" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator||
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator||</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="103" column="263"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="103" bodyend="103"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1ac7235e2eebc70e441a8f2a733e3080d6" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator||
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator||</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="103" column="421"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="103" bodyend="103"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a170d6ccca80ad287c313c4d4607ffa63" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator&amp;
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator&amp;</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="104" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="104" bodyend="104"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a17e8e5d410e9dcb279fbc225af92b754" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator&amp;
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator&amp;</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="104" column="262"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="104" bodyend="104"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a9222215fb0e46e3fa79eeb75fcc6d601" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator&amp;
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator&amp;</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="104" column="419"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="104" bodyend="104"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1ab2db8074cb71c651266ec737ce048d3e" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator^
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator^</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="105" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="105" bodyend="105"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a036fd0bd35239c7ee0089102b0b7b7de" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator^
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator^</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="105" column="262"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="105" bodyend="105"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a9fd726579e72369534a87a6ada0c8e32" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator^
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator^</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="105" column="419"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="105" bodyend="105"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a6924b352c43fbe8f17dbf32131ff20fe" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator|
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator|</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="106" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="106" bodyend="106"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a7275c084eb7c8620c567a4dd177a9952" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::operator|
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>operator|</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="106" column="262"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="106" bodyend="106"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a85b4db00a1ba2299af09ca6f6e3b6827" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::operator|
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>operator|</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="106" column="419"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="106" bodyend="106"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a34c7bc183e083e0841cf230bb0ea6f9c" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::pow
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>pow</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="107" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="107" bodyend="107"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1abc7a3dd7f9e9de9eccd441b4cf659332" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::pow
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>pow</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="107" column="256"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="107" bodyend="107"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a66697f3f317b349bbff0175097dbc942" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::pow</definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>pow</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="107" column="407"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="107" bodyend="107"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a07b8da2398e07fa52127b33f0cb48cc7" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Lhs &gt;,
                  Lhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Lhs &gt; , Lhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::exp
              </definition>
              <argsstring>(const Lhs &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>exp</name>
              <param>
                  <type>const Lhs &amp;</type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="108" column="90" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="108" bodyend="108"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a0c0a35e25db25d015506b51a973e5813" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; <ref refid="struct_space_h_1_1_lazy_1_1_expr"
                                                                             kindref="compound">Expr</ref>&lt; Rhs &gt;,
                  Rhs &gt;::value), <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                      Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt; &gt;
              </type>
              <definition>constexpr std::enable_if_t&lt;!(std::is_base_of&lt; Expr&lt; Rhs &gt; , Rhs &gt;::value),Binary_Expr&lt;decltype(
                  OP__LINE__ ), Lhs, Rhs&gt; &gt; SpaceH::Lazy::exp
              </definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Rhs &amp;rhs)</argsstring>
              <name>exp</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const Rhs &amp;</type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="108" column="256"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="108" bodyend="108"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a7ff70b47f06de88dffe582837c680cfa" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Lhs</type>
                  </param>
                  <param>
                      <type>typename Rhs</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_binary___expr" kindref="compound">
                  Binary_Expr</ref>&lt; decltype(OP__LINE__), Lhs, Rhs &gt;
              </type>
              <definition>constexpr Binary_Expr&lt;decltype( OP__LINE__ ), Lhs, Rhs&gt; SpaceH::Lazy::exp</definition>
              <argsstring>(const Expr&lt; Lhs &gt; &amp;lhs, const Expr&lt; Rhs &gt; &amp;rhs)</argsstring>
              <name>exp</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Lhs &gt;
                      &amp;
                  </type>
                  <declname>lhs</declname>
              </param>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Rhs &gt;
                      &amp;
                  </type>
                  <declname>rhs</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="108" column="407"
                        bodyfile="lazy-evaluation/lazy_expr.h" bodystart="108" bodyend="108"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1accbaeee7892349d1835e238d886a3ab9" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::operator+</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>operator+</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt;
                      &amp;
                  </type>
          <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="110" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="110" bodyend="110"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1afe246cf52d1b8e6c6480c00078459b4f" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::operator-</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>operator-</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
          <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="111" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="111" bodyend="111"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a0a6f435f2b345687c72556552642d4f9" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::operator*</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>operator*</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
          <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="112" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="112" bodyend="112"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a164429e78d6098438316b13695c8e2bb" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::operator!</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>operator!</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
          <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="113" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="113" bodyend="113"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1aa3fb1649248dddffd45eb3feb697d0be" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::operator~</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>operator~</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
            <declname>unary</declname>
        </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="114" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="114" bodyend="114"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1aff4e45f98de5e5c3f549ee6179a7a552" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::abs</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>abs</name>
              <param>
                  <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt;
                      &amp;
                  </type>
                  <declname>unary</declname>
              </param>
              <briefdescription>
              </briefdescription>
              <detaileddescription>
              </detaileddescription>
              <inbodydescription>
              </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="115" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="115" bodyend="115"/>
          </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a7cb44bbd0fd0d7ea550c510e0bdbb1f0" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::log</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>log</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
            <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="116" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="116" bodyend="116"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1aefaed9e2a7523b473eecebb53ec91263" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::log10</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>log10</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
            <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="117" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="117" bodyend="117"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a4453625bbb1c7f315145f28668b4f3e3" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::sin</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>sin</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
            <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="118" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="118" bodyend="118"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1aaceb6a39308fb02610d144db3ad90944" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::cos</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>cos</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
            <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="119" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="119" bodyend="119"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a2e9f07cc876e7379e16a970b4359d2cc" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::tan</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>tan</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
            <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="120" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="120" bodyend="120"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a200166966304fe12c853f97faac55fc8" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::asin</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>asin</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
            <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="121" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="121" bodyend="121"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a51e60901d011376fb3960f85d608d841" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::acos</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>acos</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
            <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="122" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="122" bodyend="122"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a3512ecc8ba490789397be7cd2de13238" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::atan</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>atan</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
            <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="123" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="123" bodyend="123"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a817bb1cf740aba1b2ff2f4a1f01c4cf2" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::sinh</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>sinh</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
            <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="124" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="124" bodyend="124"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1a6fa82ee0507c93a10486491440ff9074" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::cosh</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>cosh</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
            <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="125" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="125" bodyend="125"/>
      </memberdef>
          <memberdef kind="function" id="lazy__expr_8h_1abc73d2c8ac779b23217088f7c5cdcc90" prot="public" static="no"
                     constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
              <templateparamlist>
                  <param>
                      <type>typename Unary</type>
                  </param>
              </templateparamlist>
              <type>constexpr <ref refid="struct_space_h_1_1_lazy_1_1_unary___expr" kindref="compound">Unary_Expr</ref>&lt;
                  decltype(OP__LINE__), Unary &gt;
              </type>
              <definition>constexpr Unary_Expr&lt;decltype( OP__LINE__ ), Unary&gt; SpaceH::Lazy::tanh</definition>
              <argsstring>(const Expr&lt; Unary &gt; &amp;unary)</argsstring>
              <name>tanh</name>
        <param>
            <type>const <ref refid="struct_space_h_1_1_lazy_1_1_expr" kindref="compound">Expr</ref>&lt; Unary &gt; &amp;
            </type>
            <declname>unary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
              <location file="lazy-evaluation/lazy_expr.h" line="126" column="72" bodyfile="lazy-evaluation/lazy_expr.h"
                        bodystart="126" bodyend="126"/>
      </memberdef>
      <memberdef kind="function" id="slice_8h_1ae692630f6e945e4f0538c0b95ccecbb0" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr size_t</type>
        <definition>constexpr size_t SpaceH::Lazy::constexpr_slice_len</definition>
        <argsstring>(int begin, int end, int stride, size_t size)</argsstring>
        <name>constexpr_slice_len</name>
        <param>
          <type>int</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>int</type>
          <declname>end</declname>
        </param>
        <param>
          <type>int</type>
          <declname>stride</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lazy-evaluation/slice.h" line="23" column="26" bodyfile="lazy-evaluation/slice.h" bodystart="23" bodyend="38"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="lazy-evaluation/lazy_array.h" line="12" column="18"/>
  </compounddef>
</doxygen>
